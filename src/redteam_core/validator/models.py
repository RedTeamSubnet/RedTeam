from typing import Optional, Any
import hashlib
import json

from pydantic import BaseModel


class ScoringLog(BaseModel):
    score: Optional[float] = None
    miner_input: Optional[dict] = None
    miner_output: Optional[dict] = None
    validation_output: Optional[dict] = None
    error: Optional[str] = None
    baseline_score: Optional[float] = None
    input_hash: Optional[str] = None

    def model_post_init(self, __context: Any):
        if self.miner_input:
            self.input_hash = hashlib.sha256(
                json.dumps(self.miner_input).encode("utf-8")
            ).hexdigest()
        else:
            self.input_hash = None

    def public_view(self) -> "ScoringLog":
        return ScoringLog(
            score=self.score,
            miner_input=None,
            miner_output=None,
            validation_output=self.validation_output,
            error=self.error,
            baseline_score=self.baseline_score,
            input_hash=None,
        )


class ComparisonLog(BaseModel):
    similarity_score: Optional[float] = None
    miner_input: Optional[dict] = None
    miner_output: Optional[dict] = None
    reference_output: Optional[dict] = None
    error: Optional[str] = None
    input_hash: Optional[str] = None
    reason: Optional[str] = None

    reference_hotkey: Optional[str] = None
    reference_similarity_score: Optional[float] = None

    def model_post_init(self, __context: Any):
        if self.miner_input:
            self.input_hash = hashlib.sha256(
                json.dumps(self.miner_input).encode("utf-8")
            ).hexdigest()
        else:
            self.input_hash = None

    def public_view(self) -> "ComparisonLog":
        return ComparisonLog(
            similarity_score=self.similarity_score,
            miner_input=None,
            miner_output=None,
            reference_output=None,
            reason=self.reason,
            error=self.error,
            reference_hotkey=self.reference_hotkey,
            reference_similarity_score=self.reference_similarity_score,
        )


class MinerChallengeCommit(BaseModel):
    # Basic information
    miner_uid: Optional[int] = None
    miner_hotkey: Optional[str] = None
    challenge_name: Optional[str] = None
    docker_hub_id: Optional[str] = None
    commit_timestamp: Optional[float] = None
    encrypted_commit: Optional[str] = None
    key: Optional[str] = None
    commit: Optional[str] = None

    # Scoring logs with input generated by controller
    scoring_logs: list[ScoringLog] = []

    # Comparision logs, this dict map reference commit 's docker_hub_id to comparison log
    comparison_logs: dict[str, list[ComparisonLog]] = {}

    # Final score and penalty for this miner's commit
    scored_timestamp: Optional[float] = None
    score: Optional[float] = None
    penalty: Optional[float] = None

    # Accepted by having penalty less than threshold
    accepted: Optional[bool] = None

    def public_view(self) -> "MinerChallengeCommit":
        """Returns a new instance with sensitive fields (scoring logs, comparison logs) removed."""
        return MinerChallengeCommit(
            miner_uid=self.miner_uid,
            miner_hotkey=self.miner_hotkey,
            challenge_name=self.challenge_name,
            docker_hub_id=self.docker_hub_id,
            commit_timestamp=self.commit_timestamp,
            encrypted_commit=self.encrypted_commit,
            key=self.key,
            commit=self.commit,
            scoring_logs=[log.public_view() for log in self.scoring_logs],
            comparison_logs={
                ref_commit: [log.public_view() for log in logs]
                for ref_commit, logs in self.comparison_logs.items()
            },
            scored_timestamp=self.scored_timestamp,
            score=self.score,
            penalty=self.penalty,
            accepted=self.accepted,
        )

    def remove_lower_than_highest_score(self):
        """Remove all comparison logs that have scores lower than the highest score across all logs."""
        if not self.comparison_logs:
            return

        highest_score = self.get_higest_comparison_score()

        if highest_score == 0.0:
            return

        filtered_logs = {}
        for ref_commit, logs in self.comparison_logs.items():
            highest_scoring_logs = [
                log for log in logs if log.similarity_score == highest_score
            ]
            if highest_scoring_logs:
                filtered_logs[ref_commit] = highest_scoring_logs

        self.comparison_logs = filtered_logs

    def remove_redundant_logs(self):
        """This is temporary function to clear scoring logs except in index 0 and comparison logs except the highest similarity score log."""
        if len(self.scoring_logs) > 1:
            self.scoring_logs = [self.scoring_logs[0]]
        for ref_commit, logs in self.comparison_logs.items():
            if len(logs) > 1:
                # Keep only the log with highest similarity score
                highest_log = max(
                    logs, key=lambda log: log.similarity_score or float("-inf")
                )
                self.comparison_logs[ref_commit] = [highest_log]

    def get_higest_comparison_score(self) -> float:
        """Get the maximum similarity score from all comparison logs."""
        if not self.comparison_logs:
            return 0.0

        all_scores = [
            log.similarity_score
            for logs in self.comparison_logs.values()
            for log in logs
            if log.similarity_score is not None
        ]
        return max(all_scores) if all_scores else 0.0

    def get_higest_scoring_score(self) -> float:
        """Get the maximum score from all scoring logs."""
        if not self.scoring_logs:
            return 0.0

        all_scores = [log.score for log in self.scoring_logs if log.score is not None]
        return max(all_scores) if all_scores else 0.0

    def anonymize_docker_hub_ids(self) -> "MinerChallengeCommit":
        """Returns a new instance with docker hub IDs replaced with miner_uid---sha format."""

        def extract_sha_from_docker_hub_id(docker_hub_id: str, miner_uid: int) -> str:
            if not docker_hub_id:
                return docker_hub_id

            # Extract SHA256 hash after @sha256:
            if "@sha256:" in docker_hub_id:
                sha_part = docker_hub_id.split("@sha256:")[1]
                return f"{miner_uid}---{sha_part}"
            else:
                # If no @sha256: found, return original format
                return docker_hub_id

        # Create anonymized docker_hub_id for this commit
        anonymized_docker_hub_id = None
        if self.docker_hub_id and self.miner_uid is not None:
            anonymized_docker_hub_id = extract_sha_from_docker_hub_id(
                self.docker_hub_id, self.miner_uid
            )
        anonymized_commit = None
        if self.commit:
            # If commit is a docker_hub_id, anonymize it too
            anonymized_commit = extract_sha_from_docker_hub_id(
                self.commit, self.miner_uid
            )
            anonymized_commit = f"{self.challenge_name}---{anonymized_commit}"

        # Create mapping for comparison_logs keys (reference docker_hub_ids)
        anonymized_comparison_logs = {}
        for ref_docker_hub_id, logs in self.comparison_logs.items():
            # Use a generic UID for reference commits since we don't have their miner_uid
            if "@sha256:" in ref_docker_hub_id:
                sha_part = ref_docker_hub_id.split("@sha256:")[1]
                anonymized_ref_id = f"ref---{sha_part}"
            else:
                anonymized_ref_id = ref_docker_hub_id
            anonymized_comparison_logs[anonymized_ref_id] = logs

        return MinerChallengeCommit(
            miner_uid=self.miner_uid,
            miner_hotkey=self.miner_hotkey,
            challenge_name=self.challenge_name,
            docker_hub_id=anonymized_docker_hub_id,
            commit_timestamp=self.commit_timestamp,
            encrypted_commit=self.encrypted_commit,
            key=None,
            commit=anonymized_commit,
            scoring_logs=self.scoring_logs,
            comparison_logs=anonymized_comparison_logs,
            scored_timestamp=self.scored_timestamp,
            score=self.score,
            penalty=self.penalty,
            accepted=self.accepted,
        )


class MinerChallengeInfo(BaseModel):
    """
    Holds the state of a miner for a specific challenge.

    Attributes:
        miner_uid (int): Miner's UID
        miner_hotkey (str): Miner's current hotkey
        challenge_name (str): Name of the challenge
        latest_commit (Optional[MinerChallengeCommit]): Latest commit data
        best_commit (Optional[MinerChallengeCommit]): Best performing commit data
        daily_scores (dict[str, float]): Daily scores indexed by date
    """

    miner_uid: int
    miner_hotkey: str
    challenge_name: str
    latest_commit: Optional[MinerChallengeCommit] = None
    best_commit: Optional[MinerChallengeCommit] = None
    daily_scores: dict[str, float] = {}

    def update_best_commit(self, miner_commit: MinerChallengeCommit):
        """
        Updates the best commit if the new commit is accepted and has a higher score.

        Args:
            commit: New commit to evaluate
        """
        if (
            self.best_commit
            and miner_commit.encrypted_commit == self.best_commit.encrypted_commit
            and not miner_commit.accepted
        ):
            self.best_commit = None
            return

        elif not miner_commit.accepted:
            return

        elif (
            self.best_commit is None
            or miner_commit.score > self.best_commit.score
            or miner_commit.score == 1.0
        ):
            self.best_commit = miner_commit

    def public_view(self) -> "MinerChallengeInfo":
        """Returns a new instance with sensitive fields removed from commits."""
        return MinerChallengeInfo(
            miner_uid=self.miner_uid,
            miner_hotkey=self.miner_hotkey,
            challenge_name=self.challenge_name,
            latest_commit=(
                self.latest_commit.public_view() if self.latest_commit else None
            ),
            best_commit=self.best_commit.public_view() if self.best_commit else None,
            daily_scores=self.daily_scores,
        )
