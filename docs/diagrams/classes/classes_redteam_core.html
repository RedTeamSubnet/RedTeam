<html>
  <body>
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
      <div class="mermaid">
    
        classDiagram
          class AutoUpdater {
          }
          class BaseConfig {
            model_config : SettingsConfigDict
            settings_customise_sources(settings_cls: Type[BaseSettings], init_settings: PydanticBaseSettingsSource, env_settings: PydanticBaseSettingsSource, dotenv_settings: PydanticBaseSettingsSource, file_secret_settings: PydanticBaseSettingsSource) Tuple[PydanticBaseSettingsSource, ...]
          }
          class BaseController {
            challenge_info : dict
            challenge_name : str
            miner_commits : list[MinerChallengeCommit]
            reference_comparison_commits : list[MinerChallengeCommit]
            seed_inputs : list[dict]
            start_challenge()*
          }
          class BaseMiner {
            axon : Axon
            config : Config
            dendrite : Dendrite
            is_running : bool
            metagraph : Metagraph
            my_subnet_uid
            should_exit : bool
            subtensor : Subtensor
            thread : Thread
            wallet
            blacklist(synapse: Commit)* Tuple[bool, str]
            forward(synapse: Commit)* Commit
            run()
            run_in_background_thread()
            setup_bittensor_objects()
            setup_logging()
            stop_run_thread()
          }
          class BaseValidator {
            config
            current_block : int
            dendrite : Dendrite
            forward_thread : Thread
            is_running : bool
            last_update : int
            metagraph : Metagraph
            node : SubstrateInterface
            should_exit : bool
            subtensor : Subtensor
            thread : Thread
            uid
            wallet
            forward()*
            resync_metagraph()
            run()
            set_weights()*
            setup_bittensor_objects()
            setup_logging()
            synthetic_loop_in_background_thread()
          }
          class BittensorLogHandler {
            api_key
            buffer_size : int
            log_queue : Queue
            sender_thread : Thread
            stop_event : Event
            close()
            emit(record)
            flush_logs(logs)
            process_logs()
          }
          class ChallengeManager {
            challenge_incentive_weight
            challenge_info : dict
            challenge_name
            max_unique_commits
            metagraph : Metagraph
            miner_states : dict[int, MinerChallengeInfo]
            export_state(public_view: bool) dict
            get_challenge_scores()*
            get_unique_commits() set[str]
            get_unique_scored_docker_hub_ids() set[str]
            load_state(state: dict, challenge_info: dict, metagraph: bt.metagraph) 'ChallengeManager'
            update_miner_infos(miner_commits: list[MinerChallengeCommit]) list[MinerChallengeCommit]
            update_miner_scores(miner_commits: list[MinerChallengeCommit])*
          }
          class Commit {
            commit_dockers : dict
            encrypted_commit_dockers : dict
            public_keys : dict
            secret_keys : dict
            add_encrypted_commit(commit: str) str
            reveal_if_ready()
          }
          class ComparisonLog {
            error : Optional[str]
            input_hash : Optional[str]
            miner_input : Optional[dict]
            miner_output : Optional[dict]
            reason : Optional[str]
            reference_hotkey : Optional[str]
            reference_output : Optional[dict]
            reference_similarity_score : Optional[float]
            similarity_score : Optional[float]
            model_post_init(\_\_context: Any)
            public_view() 'ComparisonLog'
          }
          class Controller {
            challenge_container
            docker_client : DockerClient
            local_network : str
            max_self_comparison_score
            start_challenge()*
          }
          class FrozenBaseConfig {
            model_config : SettingsConfigDict
          }
          class InternalServicesConfig {
            API_KEY : Optional[str]
            BASE_PATH : Optional[str]
            HOST : Optional[str]
            HTTP_SCHEME : Optional[str]
            PORT : Optional[int]
            URL : Optional[AnyHttpUrl]
            model_config : SettingsConfigDict
          }
          class MainConfig {
            ALPHA_BURN_WEIGHT : Optional[float]
            CHALLENGE_DOCKER_PORT : Optional[int]
            CHALLENGE_SCORES_WEIGHT : Optional[float]
            EPOCH_LENGTH : Optional[int]
            INTERNAL_SERVICES : Optional[InternalServicesConfig]
            MINER_DOCKER_PORT : Optional[int]
            MIN_VALIDATOR_STAKE : Optional[int]
            N_CHALLENGES_PER_EPOCH : Optional[int]
            QUERY_TIMEOUT : Optional[int]
            REVEAL_INTERVAL : Optional[int]
            REWARD_APP : Optional[RewardAppConfig]
            SCORING_HOUR : Optional[int]
            SPEC_VERSION : Optional[int]
            STORAGE_API : Optional[StorageApiConfig]
            SUBNET_IMMUNITY_PERIOD : Optional[int]
            TESTNET : Optional[bool]
            VALIDATOR : Optional[ValidatorConfig]
            VERSION : Optional[str]
            model_config : SettingsConfigDict
            calculate_spec_version(values)
            is_commit_on_time(commit_timestamp: float) bool
          }
          class MinerChallengeCommit {
            accepted : Optional[bool]
            challenge_name : Optional[str]
            commit : Optional[str]
            commit_timestamp : Optional[float]
            comparison_logs : dict[str, list[ComparisonLog]]
            docker_hub_id : Optional[str]
            encrypted_commit : Optional[str]
            key : Optional[str]
            miner_hotkey : Optional[str]
            miner_uid : Optional[int]
            penalty : Optional[float]
            score : Optional[float]
            scored_timestamp : Optional[float]
            scoring_logs : list[ScoringLog]
            anonymize_docker_hub_ids() 'MinerChallengeCommit'
            get_higest_comparison_score() float
            get_higest_scoring_score() float
            public_view() 'MinerChallengeCommit'
          }
          class MinerChallengeInfo {
            best_commit : Optional[MinerChallengeCommit]
            challenge_name : str
            daily_scores : dict[str, float]
            latest_commit : Optional[MinerChallengeCommit]
            miner_hotkey : str
            miner_uid : int
            public_view() 'MinerChallengeInfo'
            update_best_commit(miner_commit: MinerChallengeCommit)
          }
          class MinerManager {
            challenge_managers : dict[str, ChallengeManager]
            metagraph : Metagraph
            weights_to_redistribute : float
            exclude_same_miner(scores, ignore_ip: str) np.ndarray
            get_onchain_scores(n_uids: int) np.ndarray
            update_challenge_managers(challenge_managers: dict[str, ChallengeManager])
          }
          class RewardAppConfig {
            BASE_PATH : Optional[str]
            HOST : Optional[str]
            HTTP_SCHEME : Optional[str]
            PORT : Optional[int]
            URL : Optional[AnyHttpUrl]
            model_config : SettingsConfigDict
          }
          class ScoringLog {
            baseline_score : Optional[float]
            error : Optional[str]
            input_hash : Optional[str]
            miner_input : Optional[dict]
            miner_output : Optional[dict]
            score : Optional[float]
            validation_output : Optional[dict]
            model_post_init(\_\_context: Any)
            public_view() 'ScoringLog'
          }
          class StorageApiConfig {
            BASE_PATH : Optional[str]
            HOST : Optional[str]
            HTTP_SCHEME : Optional[str]
            PORT : Optional[int]
            URL : Optional[AnyHttpUrl]
            model_config : SettingsConfigDict
          }
          class StorageManager {
            active_challenges
            cache_dir : str
            hf_api : HfApi
            hf_repo_id : str
            local_caches : dict[Cache]
            storage_thread : Thread
            validator_request_header_fn : Callable[[Union[bytes, str, dict, BaseModel]], str]
            get_latest_validator_state_from_cache(validator_uid: int, validator_hotkey: str) Optional[dict]
            get_latest_validator_state_from_storage(validator_uid: int, validator_hotkey: str) Optional[dict]
            hash_cache_key(cache_key: str) str
            sync_storage_to_cache()*
            update_commit(commit: MinerChallengeCommit, async_update: bool, retry_config: dict)
            update_commit_batch(commits: list[MinerChallengeCommit], async_update: bool)
            update_repo_id()
            update_validator_state(data: dict, async_update: bool)
          }
          class UpdateRequirementsRestart {
            url : str
            run()
          }
          class ValidatorConfig {
            UPDATE_BRANCH_NAME : Optional[str]
            UPDATE_RATE_MINUTES : Optional[int]
            model_config : SettingsConfigDict
          }
          Controller --|> BaseController
          FrozenBaseConfig --|> BaseConfig
          InternalServicesConfig --|> BaseConfig
          RewardAppConfig --|> BaseConfig
          StorageApiConfig --|> BaseConfig
          ValidatorConfig --|> BaseConfig
          ChallengeManager --> MinerChallengeInfo : miner_states
          ChallengeManager --o MinerManager : challenge_managers
          MinerChallengeCommit --o BaseController : miner_commits
          MinerChallengeCommit --o BaseController : reference_comparison_commits
  
       </div>
  </body>
</html>
